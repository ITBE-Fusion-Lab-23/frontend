<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>UI Manager Component</title>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      .full-screen {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div class="full-screen" id="container"></div>
    <script type="module">
      import * as OBC from "openbim-components";
      import * as THREE from "three";
      import * as dat from "three/examples/jsm/libs/lil-gui.module.min";

      // basic scene
      const viewerContainer = document.getElementById("container");
      const components = new OBC.Components();
      components.scene = new OBC.SimpleScene(components);
      components.renderer = new OBC.PostproductionRenderer(components, viewerContainer);
      components.camera = new OBC.SimpleCamera(components);
      components.raycaster = new OBC.SimpleRaycaster(components);
      components.init();

      //components.camera.controls.setLookAt(10, 10, 10, 0, 0, 0);

      const scene = components.scene.get();

      components.scene.setup();

      const grid = new OBC.SimpleGrid(components, new THREE.Color(0x666666));

      components.renderer.postproduction.enabled = true;
      components.renderer.postproduction.customEffects.excludedMeshes.push(grid.get());

      /* ----- ifc load ----- */
      // fragments
      let fragments = new OBC.FragmentManager(components);
      let fragmentIfcLoader = new OBC.FragmentIfcLoader(components);

      // Setup IFCloader with WSAM (calibrating the converter)
      await fragmentIfcLoader.setup();

      fragmentIfcLoader.settings.wasm = {
        path: "https://unpkg.com/web-ifc@0.0.46/",
        absolute: true,
      };

      fragmentIfcLoader.settings.webIfc.COORDINATE_TO_ORIGIN = true;
      fragmentIfcLoader.settings.webIfc.OPTIMIZE_PROFILES = true;

      // import IFC model and convert to fragment
      const file = await fetch("/bridgeA.ifc");
      const data = await file.arrayBuffer();
      const buffer = new Uint8Array(data);
      const model = await fragmentIfcLoader.load(buffer, "Sample IFC");
      scene.add(model);

      // Delete button
      const mainToolbar = new OBC.Toolbar(components, {
        name: "Main Toolbar",
        position: "bottom",
      });
      components.ui.addToolbar(mainToolbar);

      function disposeFragments() {
        fragments.dispose();
      }
      const setting = {
        disposeFragments: () => disposeFragments(),
      };

      const disposeButton = new OBC.Button(components);
      disposeButton.materialIcon = "delete";
      disposeButton.tooltip = "Delete model";
      mainToolbar.addChild(disposeButton);
      disposeButton.onClick.add(() => disposeFragments());
      
      /* ------- Classifying Fragment ------- */
      const classifier = new OBC.FragmentClassifier(components);
      const properties = await fetch('/sampleIFC.json');
      model.properties = await properties.json();

      //classifier.byStorey(model);
      //classifier.byIfcRel(model);
      classifier.byEntity(model);

      const modelTree = new OBC.FragmentTree(components);
      await modelTree.init();
  
      modelTree.update(['entities']); // argument should be array

      modelTree.onSelected.add(({ items, visible}) => {
        if(visible) {
          highlighter.highlightByID('select', items, true, true);
        }
      });

      modelTree.onHovered.add(({items, visible}) => {
        if(visible) {
          highlighter.highlightByID('hover', items);
        }
      });
      
      mainToolbar.addChild(modelTree.uiElement.get('main'));
      components.ui.addToolbar(toolbar);
      console.log(model.properties);
  
      /*----- ifc properties Manager ------*/
      const propsProcessor = new OBC.IfcPropertiesProcessor(components);
      const propsManager = new OBC.IfcPropertiesManager(components);
      propsProcessor.propertiesManager = propsManager;

      propsProcessor.process(model);
      propsManager.onRequestFile.add(async () => {
        const feched = await fetch('/bridgeA.ifc');
        propsManager.IfcToExport = await feched.arrayBuffer();
      })

      // highlighter
      const highlighter = new OBC.FragmentHighlighter(components, fragments);
      highlighter.zoomToSelection = true;
      highlighter.setup();
  
      components.renderer.postproduction.customEffects.outlineEnabled = true;
      highlighter.outlinesEnabled = true;
  
      const highlighterEvents = highlighter.events;
      highlighterEvents.select.onClear.add(() => {
          propsProcessor.cleanPropertiesList();
      });

      highlighterEvents.select.onHighlight.add(
        (selection) => {
            const fragmentID = Object.keys(selection)[0];
            const expressID = Number([...selection[fragmentID]][0]);
            let model
            for (const group of fragments.groups) {
                const fragmentFound = Object.values(group.keyFragments).find(id => id === fragmentID)
                if (fragmentFound) model = group;
            }
            propsProcessor.renderProperties(model, expressID);
        }
    );

    mainToolbar.addChild(propsProcessor.uiElement.get("main"));
  
    </script>
  </body>
</html>
